{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 55, "column": 0}, "map": {"version":3,"sources":["file:///home/david/Desktop/msaidizi/web/src/app/api/autocomplete/route.js"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\n\nconst API_URL = process.env.NEXT_PUBLIC_API_URL\n\nexport async function GET(request) {\n  const { searchParams } = new URL(request.url);\n  const query = searchParams.get('q');\n  \n  // 1. Fetch data from the external API\n  const res = await fetch(`${API_URL}/api/products`, { \n    next: { revalidate: 0 } \n  }); \n\n  // Check for failed fetch response\n  if (!res.ok) {\n    return NextResponse.json({ message: 'Failed to fetch products' }, { status: res.status });\n  }\n\n  const responseData = await res.json();\n  \n  // 2. ðŸŽ¯ CRITICAL FIX: Extract the array from the 'products' property\n  const productsArray = responseData.products;\n\n  // 3. Ensure the extracted data is an array before proceeding\n  if (!Array.isArray(productsArray)) {\n    // If the data structure changes, log an error and return empty array\n    console.error('Expected \"products\" array not found in API response. Received:', responseData);\n    return NextResponse.json([], { status: 500 });\n  }\n\n  // Handle case where no search query is provided\n  if (!query) {\n    return NextResponse.json([], { status: 200 });\n  }\n\n  // Pre-process the query for case-insensitive filtering\n  const lowerCaseQuery = query.toLowerCase();\n\n  // 4. Filtering Logic (using the corrected array)\n  const mockResults = productsArray.filter(item => {\n    // Check if item.name exists and includes the query\n    const nameMatch = item.name \n        ? item.name.toLowerCase().includes(lowerCaseQuery) \n        : false;\n        \n    // Check if item.partNumber exists and includes the query\n    const partNumberMatch = item.partNumber \n        ? item.partNumber.toLowerCase().includes(lowerCaseQuery) \n        : false;\n        \n    // Return true if either name or partNumber matches\n    return nameMatch || partNumberMatch;\n  });\n\n  return NextResponse.json(mockResults);\n}"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM;AAEC,eAAe,IAAI,OAAO;IAC/B,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,IAAI,QAAQ,GAAG;IAC5C,MAAM,QAAQ,aAAa,GAAG,CAAC;IAE/B,sCAAsC;IACtC,MAAM,MAAM,MAAM,MAAM,GAAG,QAAQ,aAAa,CAAC,EAAE;QACjD,MAAM;YAAE,YAAY;QAAE;IACxB;IAEA,kCAAkC;IAClC,IAAI,CAAC,IAAI,EAAE,EAAE;QACX,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,SAAS;QAA2B,GAAG;YAAE,QAAQ,IAAI,MAAM;QAAC;IACzF;IAEA,MAAM,eAAe,MAAM,IAAI,IAAI;IAEnC,qEAAqE;IACrE,MAAM,gBAAgB,aAAa,QAAQ;IAE3C,6DAA6D;IAC7D,IAAI,CAAC,MAAM,OAAO,CAAC,gBAAgB;QACjC,qEAAqE;QACrE,QAAQ,KAAK,CAAC,kEAAkE;QAChF,OAAO,gJAAY,CAAC,IAAI,CAAC,EAAE,EAAE;YAAE,QAAQ;QAAI;IAC7C;IAEA,gDAAgD;IAChD,IAAI,CAAC,OAAO;QACV,OAAO,gJAAY,CAAC,IAAI,CAAC,EAAE,EAAE;YAAE,QAAQ;QAAI;IAC7C;IAEA,uDAAuD;IACvD,MAAM,iBAAiB,MAAM,WAAW;IAExC,iDAAiD;IACjD,MAAM,cAAc,cAAc,MAAM,CAAC,CAAA;QACvC,mDAAmD;QACnD,MAAM,YAAY,KAAK,IAAI,GACrB,KAAK,IAAI,CAAC,WAAW,GAAG,QAAQ,CAAC,kBACjC;QAEN,yDAAyD;QACzD,MAAM,kBAAkB,KAAK,UAAU,GACjC,KAAK,UAAU,CAAC,WAAW,GAAG,QAAQ,CAAC,kBACvC;QAEN,mDAAmD;QACnD,OAAO,aAAa;IACtB;IAEA,OAAO,gJAAY,CAAC,IAAI,CAAC;AAC3B","debugId":null}}]
}